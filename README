Trucs à faire (Guilhem) :
  VAR:
    - remodifier l'ordre d'évaluation des expressions ?
      Pour l'instant, si g modifie la variable dont l'adresse lui est donnée, a + g(&a) n'est pas évaluée correctement.
      On pourrait régler le problème en empilant d'abord a, évaluer g(&a), puis l'additioner à là on a empilé a.
      Par contre c'est pas ce qu'il y a de plus performant donc il faudra détecter quand c'est nécessaire.
      (en supposant par ailleurs que si on ne lui file pas l'adresse de la variable, g est incapable de modifier sa valeur,
      quand bien même si on sait comment est structurée la pile c'est en fait possible).
    - virer FUN ?

  - adapter tous les langages pour l'arrivée des librairies ->
    autoriser @ dans les noms, sauf à partir de TYP. Nom d'une fonction f de la librairie l dans TYP: f@l (comme ça on est sûr que le nom est pas pris)

Adresse des paramètres dans les appels terminaux :
  Comme certains paramètres sont recopiés, leur adresse change. Exemple :
  # Terminal
  f(a) {
    return g(&a);
  }

  # Non terminal
  f(a) {
    var tmp := g(&a);
    return tmp;
  }

  Dans le cas terminal, a fait potentiellement référence à une variable locale a dont la valeur est celle du paramètre a, et
  qui a été déclarée avant d'éviter les conflits des appels terminaux. &a pointe donc dans la zone des variables locales.
  Dans le deuxième cas, a fait toujours référence au paramètre puisqu'il n'y a pas de déclaration implicite. Donc &a 
  renverra toujours l'adresse du paramètre.

  Ces deux fonctions sont très similaires mais ont donc des comportements différents. Dans le cas de la première, ce comportement
  peut même changer en fonction des optimisations des appels terminaux, ce qui en devrait pas être le cas.

  Si g modifie la valeur pointée par son paramètre :
  - dans le cas non terminal, peu importe. L'espace du paramètre modifié et de l'argument de la fonction appelée n'est pas le même,
    et puisque on retourne juste après, la modification ne sera jamais visible. En revanche on pourrait y accéder entre les deux instructions ;
    mais dans ce cas l'appel n'est de toute façon pas terminale, même en cherchant plus finement.
  - dans le cas terminal, l'espace est partagé. Donc si on n'y fait pas attention, la modification peut affecter la fonction appelée - 
    mais pas toujours,en fonction des optimisations.
  Ce comportement est indésirable. Lors de la recherche des paramètres à réempiler, il faut donc y inclure les paramètres dont on utilise 
  l'adresse ; de cette façon, il n'y a pas d'effets de bord indésirable.

Bug de VAR :
  Les expressions ne sont pas évaluées dans le bon ordre.
  Dans terminal.var, l_control renvoie 'g' au lieu de 'f' parce que l_aux est appelé, puis a + b est évalué et empilé, et ensuite function_result.
  L'ordre désirable est en fait
    - évaluer et empiler a + b
    - évaluer et empiler l_aux(&b)
      -> l_aux(&b);
         empiler function_result
    - évaluer f et l'appeler
  L'ordre visé actuel est le même, sauf pour f qui est évalué en premier. Il faudra changer ça.
  Les arguments des appels devront donc être empilés par... VAR. FUN devient bien inutile.
