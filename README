Organisation des fichiers :
  Chaque langage dispose d'un dossier propre (CLL, FUN et VAR sont tous dans un dossier différent de var/).
  Ces dossiers contiennent le lexer, le parser et le compilateur.
  Cependant, la part la plus importante du code se trouve dans le dossier utils/ qui contient non seulement
  des modules comme Tagset et Cycle souvent utilisés, mais aussi les arbres de syntaxe des langages et des 
  fonctions pour les traduire en un autre langage, les écrire dans un fichier, etc.
  Le dossier test contient divers programmes pour chacun des langages.


Comment utiliser le makefile :
  Pour chaque langage :
    - build_<langage>
      Compile tous les programmes OCaml nécessaires à la compilation d'un programme du langage désiré.
    - run_<langage> file=<fichier de test>
      Appelle la commande build correspondante, réalise la compilation du <fichier de test> vers le 
      bytecode, et l'exécute avec la VM. Le programme doit se trouver dans test/ et l'extension ne doit 
      pas être précisée.

  Commandes spéciales :
    - clear
      Supprime tous les fichiers de compilation de façon à ne garder que le code source, aussi bien
      pour le code OCaml que pour les fichiers test.
    - build_chain_compiler
      Un compilateur plus efficace (voir paragraphe suivant).

  ChainCompiler est l'exécutable fourni à la fin de la commande make build_chain_compiler. Elle 
  se trouve dans le fichier MainCompiler. Grâce au module Arg de ocaml, cela nous a permis de crée une
  commande parsant des arguments en ligne de commande. L'option -help vous permettra de connaitre 
  les effets de chaque options. Pour une utilisation simple de ChainCompiler, la commande est :
    MainCompiler/ChainCompiler -o sortie test/var/test1.var

  Pour l'instant, un fichier est parsé, traduit en un arbre de syntaxe lui-même traduit dans le langage
  précédent. Le résultat est écrit dans un fichier et on répète le procédé jusqu'à arriver au bytecode.
  Le compilateur chaîné peut passer d'arbre en arbre sans passer par des fichiers, fichiers qu'il peut 
  écrire lui-même avec la bonne option.


Extensions réalisées pour le module CLL / FUN / VAR :
  - arguments du main pour l'interpréteur VAR
    Le nombre d'arguments est fixe et pas de la forme argc/argv.

  - références et passage par référence
    Les références sont implémentées depuis ART. Les passages par référence ont été implémentés en FUN.

  - déclaration des variables au fil de l'eau
    Notre variante de VAR considère les déclarations de variables locales comme des instructions.
    Les variables sont automatiquement détruites à la fin d'un bloc.
    Il est aussi possible de déclarer une variable dans l'en-tête d'une boucle for.

    Les variables globales fonctionnent un peu différemment.
    Une variable globale initialisée avec une valeur immédiate (les entiers et les booléens, qu'on 
    pourrait facilement élargir aux valeurs constantes, comme 5 + 12) sont initialisées au niveau du 
    bytecode avec cette valeur directement. Les autres variables globales sont initialisées dans 
    l'ordre de leur apparition, et valent 0 auparavant. Nous avons fait ce choix en tant que compromis entre :
      - interdire de référencer une variable globale déclarée ultérieurement. Pour des raisons de cohérence,
      il faudrait alors interdire d'appeler des fonctions déclarées après parce qu'elles pourraient agir
      sur des variables globales pas encore initialisées. On perd la récursivité mutuelle des fonctions.

      - garder la récursivité mutuelle mais n'itialiser qu'avec des immédiats.

      Si VAR était un langage de haut niveau, nous aurions probablement pris la première option,
      mais ici nous voulions éviter d'imposer des limitations pour ne pas compliquer la réalisation des langages 
      suivants. Nous pourrions revenir sur nos choix et prendre la deuxième option plus tard.

  - appels de fonctions dans les expressions
    Implémentée en VAR. Pour atteindre ce résultat, VAR réserve de l'espace pour des variables locales
    anonymes qui stockeront le résultat des appels.
  
  - récursion terminale
    Nous n'avons pas encore implémentée cette optimisation mais c'est la suite logique des appels de 
    fonctions dans des expressions, puisqu'il est très facile de détecter une instruction de la forme
    return appel_terminal().

  Pour le rendu du module précédent, nous n'avions pas fait STKCompilerAlloc. Afin de garder notre version
  des langages, nous l'avons donc réalisé pour ce module puisque c'était nécessaire pour CLL.

  Le programme test/var/calls_in_for.var ne compile pas comme il le devrait. Résoudre ce bug est notre 
  priorité pour le moment.
